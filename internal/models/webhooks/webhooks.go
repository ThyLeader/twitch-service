// Code generated by gnorm, DO NOT EDIT!

package webhooks

import (
	"context"
	"time"

	"github.com/coadler/twitch/internal/models"
	"github.com/pkg/errors"
)

// TableName is the primary table that this particular gnormed file deals with.
const TableName = "webhooks"

// Row represents a row from 'webhooks'.
type Row struct {
	ID        string    // id (PK)
	CreatedAt time.Time // created_at
	Token     string    // token
	UpdatedAt time.Time // updated_at
}

// Field values for every column in Webhooks.
var (
	CreatedAtCol models.TimeTimeField = "created_at"
	IDCol        models.StringField   = "id"
	TokenCol     models.StringField   = "token"
	UpdatedAtCol models.TimeTimeField = "updated_at"
)

// All retrieves all rows from 'webhooks' as a slice of Row.
func All(ctx context.Context, db models.DB) ([]*Row, error) {
	const sqlstr = `SELECT
		created_at, id, token, updated_at
		FROM public.webhooks`

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "query Webhooks")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.CreatedAt,
			&r.ID,
			&r.Token,
			&r.UpdatedAt,
		)
		if err != nil {
			return nil, errors.Wrap(err, "all Webhooks")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// CountQuery retrieve one row from 'webhooks'.
func CountQuery(ctx context.Context, db models.DB, where models.WhereClause) (int, error) {
	const origsqlstr = `SELECT
		count(*) as count
		FROM public.webhooks WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	count := 0
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "count Webhooks")
	}
	return count, nil
}

// Query retrieves rows from 'webhooks' as a slice of Row.
func Query(ctx context.Context, db models.DB, where models.WhereClause) ([]*Row, error) {
	const origsqlstr = `SELECT
		id, token, created_at, updated_at
		FROM public.webhooks WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.Wrap(err, "query Webhooks")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID,
			&r.Token,
			&r.CreatedAt,
			&r.UpdatedAt,
		)
		if err != nil {
			return nil, errors.Wrap(err, "query Webhooks")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// QueryOrder retrieves rows from 'webhooks' as a slice of Row in a particular order.
func QueryOrder(ctx context.Context, db models.DB, where models.WhereClause, orderby models.OrderBy) ([]*Row, error) {
	const origsqlstr = `SELECT
		id, token, created_at, updated_at
		FROM public.webhooks WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + orderby.String()

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.Wrap(err, "query Webhooks")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID,
			&r.Token,
			&r.CreatedAt,
			&r.UpdatedAt,
		)
		if err != nil {
			return nil, errors.Wrap(err, "query Webhooks")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// One retrieve one row from 'webhooks'.
func One(ctx context.Context, db models.DB, where models.WhereClause) (*Row, error) {
	const origsqlstr = `SELECT
		id, token, created_at, updated_at
		FROM public.webhooks WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&r.ID,
		&r.Token,
		&r.CreatedAt,
		&r.UpdatedAt,
	)
	if err != nil {
		return nil, errors.Wrap(err, "queryOne Webhooks")
	}
	return r, nil
}

// First retrieve one row from 'webhooks' when sorted by orderby.
func First(ctx context.Context, db models.DB, where models.WhereClause, orderby models.OrderBy) (*Row, error) {
	const origsqlstr = `SELECT
		id, token, created_at, updated_at
		FROM public.webhooks WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + orderby.String()

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&r.ID,
		&r.Token,
		&r.CreatedAt,
		&r.UpdatedAt,
	)
	if err != nil {
		return nil, errors.Wrap(err, "queryFirst Webhooks")
	}
	return r, nil
}

// Find retrieves a row from 'webhooks' by its primary key(s).
func Find(ctx context.Context, db models.DB,
	id string,
) (*Row, error) {
	const sqlstr = `SELECT
		created_at, id, token, updated_at
	FROM public.webhooks WHERE ( id = $1 )`

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr,
		id,
	).Scan(&r.CreatedAt,
		&r.ID,
		&r.Token,
		&r.UpdatedAt,
	)
	if err != nil {
		return nil, errors.Wrap(err, "find Webhooks")
	}
	return r, nil
}

// Insert inserts the row into the database.
func Insert(ctx context.Context, db models.DB, r *Row) error {
	const sqlstr = `INSERT INTO public.webhooks ` +
		`(
			id, token
		) VALUES (
			$1, $2
		) ` +
		`RETURNING
			created_at, updated_at, id
		`

	err := db.QueryRowContext(ctx, sqlstr, &r.ID,

		&r.Token,
	).Scan(&r.CreatedAt, &r.UpdatedAt, &r.ID)

	return errors.Wrap(err, "insert Webhooks")
}

// Update updates the Row in the database.
func Update(ctx context.Context, db models.DB, r *Row) error {
	const sqlstr = `UPDATE public.webhooks SET (
			id, token
		) = (
			$1, $2
		) WHERE
	        id = $3
		RETURNING
			created_at, updated_at
		`

	err := db.QueryRowContext(ctx, sqlstr, r.ID, r.Token, r.ID).Scan(&r.CreatedAt, &r.UpdatedAt)
	return errors.Wrap(err, "update Webhooks:")
}

// InsertIgnore inserts the row into the database but ignores conflicts
func InsertIgnore(ctx context.Context, db models.DB, r *Row, constraint string) error {
	sqlstr := `INSERT INTO public.webhooks ` +
		`(
			id, token
		) VALUES (
			$1, $2
		) ` +
		`ON CONFLICT ON CONSTRAINT ` + constraint + ` DO NOTHING `
	_, err := db.ExecContext(ctx, sqlstr, r.ID, r.Token)
	return errors.Wrap(err, "insert ignore Webhooks")
}

// Set sets a single column on an existing row in the database.
func Set(ctx context.Context, db models.DB, set models.Where, where models.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.webhooks SET ` +
		set.Field + " = $1 " +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{set.Value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "set Webhooks")
	}
	return res.RowsAffected()
}

// AppendInt64 adds a value to a field
func AppendInt64(ctx context.Context, db models.DB, name string, value interface{}, where models.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.webhooks SET ` +
		name + " = array_append(" + name + ", $1::bigint) " +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "append_int64 Webhooks")
	}
	return res.RowsAffected()
}

// Inc increments the value of a single column on an existing row in the database.
func Inc(ctx context.Context, db models.DB, inc models.Where, where models.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.webhooks SET ` +
		inc.Field + " = " + inc.Field + " + $1" +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{inc.Value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "inc Webhooks")
	}
	return res.RowsAffected()
}

// Upsert performs an insert-or-update in one DB call for Webhooks.
// Unlike insert, upsert requires that you have set any IDs on the row you're upserting.
// NOTE: PostgreSQL 9.5+ only
func Upsert(ctx context.Context, db models.DB, r *Row) error {

	const sqlstr = `INSERT INTO public.webhooks (
		id, token
	) VALUES (
		$1, $2
	) ON CONFLICT (id) DO UPDATE SET (
		id, token
	) = (
		$1, $2
	)`

	_, err := db.ExecContext(ctx, sqlstr, r.ID, r.Token)
	return errors.Wrap(err, "upsert Webhooks")
}

// Delete deletes the Row from the database. Returns the number of items deleted.
func Delete(ctx context.Context,
	db models.DB,
	id string,
) (int64, error) {
	const sqlstr = `DELETE FROM public.webhooks 
	WHERE
	  id = $1
	`

	res, err := db.ExecContext(ctx, sqlstr, id)
	if err != nil {
		return 0, errors.Wrap(err, "delete Webhooks")
	}
	rows, err := res.RowsAffected()
	if err != nil {
		return 0, err
	}
	return rows, nil
}

// DeleteWhere deletes Rows from the database and returns the number of rows deleted.
func DeleteWhere(ctx context.Context, db models.DB, where models.WhereClause) (int64, error) {
	const origsqlstr = `DELETE FROM public.webhooks WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	res, err := db.ExecContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return 0, errors.Wrap(err, "delete Webhooks")
	}
	return res.RowsAffected()
}

// DeleteAll deletes all Rows from the database and returns the number of rows deleted.
func DeleteAll(ctx context.Context, db models.DB) (int64, error) {
	const sqlstr = `DELETE FROM public.webhooks`

	res, err := db.ExecContext(ctx, sqlstr)
	if err != nil {
		return 0, errors.Wrap(err, "deleteall Webhooks")
	}
	return res.RowsAffected()
}
