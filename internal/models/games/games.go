// Code generated by gnorm, DO NOT EDIT!

package games

import (
	"context"
	"time"

	"github.com/coadler/twitch/internal/models"
	"github.com/pkg/errors"
)

// TableName is the primary table that this particular gnormed file deals with.
const TableName = "games"

// Row represents a row from 'games'.
type Row struct {
	ID        int       // id (PK)
	BoxArtURL string    // box_art_url
	CreatedAt time.Time // created_at
	Name      string    // name
	UpdatedAt time.Time // updated_at
}

// Field values for every column in Games.
var (
	BoxArtURLCol models.StringField   = "box_art_url"
	CreatedAtCol models.TimeTimeField = "created_at"
	IDCol        models.IntField      = "id"
	NameCol      models.StringField   = "name"
	UpdatedAtCol models.TimeTimeField = "updated_at"
)

// All retrieves all rows from 'games' as a slice of Row.
func All(ctx context.Context, db models.DB) ([]*Row, error) {
	const sqlstr = `SELECT
		box_art_url, created_at, id, name, updated_at
		FROM public.games`

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "query Games")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.BoxArtURL,
			&r.CreatedAt,
			&r.ID,
			&r.Name,
			&r.UpdatedAt,
		)
		if err != nil {
			return nil, errors.Wrap(err, "all Games")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// CountQuery retrieve one row from 'games'.
func CountQuery(ctx context.Context, db models.DB, where models.WhereClause) (int, error) {
	const origsqlstr = `SELECT
		count(*) as count
		FROM public.games WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	count := 0
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "count Games")
	}
	return count, nil
}

// Query retrieves rows from 'games' as a slice of Row.
func Query(ctx context.Context, db models.DB, where models.WhereClause) ([]*Row, error) {
	const origsqlstr = `SELECT
		id, name, box_art_url, created_at, updated_at
		FROM public.games WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.Wrap(err, "query Games")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID,
			&r.Name,
			&r.BoxArtURL,
			&r.CreatedAt,
			&r.UpdatedAt,
		)
		if err != nil {
			return nil, errors.Wrap(err, "query Games")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// QueryOrder retrieves rows from 'games' as a slice of Row in a particular order.
func QueryOrder(ctx context.Context, db models.DB, where models.WhereClause, orderby models.OrderBy) ([]*Row, error) {
	const origsqlstr = `SELECT
		id, name, box_art_url, created_at, updated_at
		FROM public.games WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + orderby.String()

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.Wrap(err, "query Games")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID,
			&r.Name,
			&r.BoxArtURL,
			&r.CreatedAt,
			&r.UpdatedAt,
		)
		if err != nil {
			return nil, errors.Wrap(err, "query Games")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// One retrieve one row from 'games'.
func One(ctx context.Context, db models.DB, where models.WhereClause) (*Row, error) {
	const origsqlstr = `SELECT
		id, name, box_art_url, created_at, updated_at
		FROM public.games WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&r.ID,
		&r.Name,
		&r.BoxArtURL,
		&r.CreatedAt,
		&r.UpdatedAt,
	)
	if err != nil {
		return nil, errors.Wrap(err, "queryOne Games")
	}
	return r, nil
}

// First retrieve one row from 'games' when sorted by orderby.
func First(ctx context.Context, db models.DB, where models.WhereClause, orderby models.OrderBy) (*Row, error) {
	const origsqlstr = `SELECT
		id, name, box_art_url, created_at, updated_at
		FROM public.games WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + orderby.String()

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&r.ID,
		&r.Name,
		&r.BoxArtURL,
		&r.CreatedAt,
		&r.UpdatedAt,
	)
	if err != nil {
		return nil, errors.Wrap(err, "queryFirst Games")
	}
	return r, nil
}

// Find retrieves a row from 'games' by its primary key(s).
func Find(ctx context.Context, db models.DB,
	id int,
) (*Row, error) {
	const sqlstr = `SELECT
		box_art_url, created_at, id, name, updated_at
	FROM public.games WHERE ( id = $1 )`

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr,
		id,
	).Scan(&r.BoxArtURL,
		&r.CreatedAt,
		&r.ID,
		&r.Name,
		&r.UpdatedAt,
	)
	if err != nil {
		return nil, errors.Wrap(err, "find Games")
	}
	return r, nil
}

// Insert inserts the row into the database.
func Insert(ctx context.Context, db models.DB, r *Row) error {
	const sqlstr = `INSERT INTO public.games ` +
		`(
			box_art_url, id, name
		) VALUES (
			$1, $2, $3
		) ` +
		`RETURNING
			created_at, updated_at, id
		`

	err := db.QueryRowContext(ctx, sqlstr, &r.BoxArtURL,

		&r.ID,

		&r.Name,
	).Scan(&r.CreatedAt, &r.UpdatedAt, &r.ID)

	return errors.Wrap(err, "insert Games")
}

// Update updates the Row in the database.
func Update(ctx context.Context, db models.DB, r *Row) error {
	const sqlstr = `UPDATE public.games SET (
			box_art_url, id, name
		) = (
			$1, $2, $3
		) WHERE
	        id = $4
		RETURNING
			created_at, updated_at
		`

	err := db.QueryRowContext(ctx, sqlstr, r.BoxArtURL, r.ID, r.Name, r.ID).Scan(&r.CreatedAt, &r.UpdatedAt)
	return errors.Wrap(err, "update Games:")
}

// InsertIgnore inserts the row into the database but ignores conflicts
func InsertIgnore(ctx context.Context, db models.DB, r *Row, constraint string) error {
	sqlstr := `INSERT INTO public.games ` +
		`(
			box_art_url, id, name
		) VALUES (
			$1, $2, $3
		) ` +
		`ON CONFLICT ON CONSTRAINT ` + constraint + ` DO NOTHING `
	_, err := db.ExecContext(ctx, sqlstr, r.BoxArtURL, r.ID, r.Name)
	return errors.Wrap(err, "insert ignore Games")
}

// Set sets a single column on an existing row in the database.
func Set(ctx context.Context, db models.DB, set models.Where, where models.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.games SET ` +
		set.Field + " = $1 " +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{set.Value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "set Games")
	}
	return res.RowsAffected()
}

// AppendInt64 adds a value to a field
func AppendInt64(ctx context.Context, db models.DB, name string, value interface{}, where models.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.games SET ` +
		name + " = array_append(" + name + ", $1::bigint) " +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "append_int64 Games")
	}
	return res.RowsAffected()
}

// Inc increments the value of a single column on an existing row in the database.
func Inc(ctx context.Context, db models.DB, inc models.Where, where models.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.games SET ` +
		inc.Field + " = " + inc.Field + " + $1" +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{inc.Value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "inc Games")
	}
	return res.RowsAffected()
}

// Upsert performs an insert-or-update in one DB call for Games.
// Unlike insert, upsert requires that you have set any IDs on the row you're upserting.
// NOTE: PostgreSQL 9.5+ only
func Upsert(ctx context.Context, db models.DB, r *Row) error {

	const sqlstr = `INSERT INTO public.games (
		box_art_url, id, name
	) VALUES (
		$1, $2, $3
	) ON CONFLICT (id) DO UPDATE SET (
		box_art_url, id, name
	) = (
		$1, $2, $3
	)`

	_, err := db.ExecContext(ctx, sqlstr, r.BoxArtURL, r.ID, r.Name)
	return errors.Wrap(err, "upsert Games")
}

// Delete deletes the Row from the database. Returns the number of items deleted.
func Delete(ctx context.Context,
	db models.DB,
	id int,
) (int64, error) {
	const sqlstr = `DELETE FROM public.games 
	WHERE
	  id = $1
	`

	res, err := db.ExecContext(ctx, sqlstr, id)
	if err != nil {
		return 0, errors.Wrap(err, "delete Games")
	}
	rows, err := res.RowsAffected()
	if err != nil {
		return 0, err
	}
	return rows, nil
}

// DeleteWhere deletes Rows from the database and returns the number of rows deleted.
func DeleteWhere(ctx context.Context, db models.DB, where models.WhereClause) (int64, error) {
	const origsqlstr = `DELETE FROM public.games WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	res, err := db.ExecContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return 0, errors.Wrap(err, "delete Games")
	}
	return res.RowsAffected()
}

// DeleteAll deletes all Rows from the database and returns the number of rows deleted.
func DeleteAll(ctx context.Context, db models.DB) (int64, error) {
	const sqlstr = `DELETE FROM public.games`

	res, err := db.ExecContext(ctx, sqlstr)
	if err != nil {
		return 0, errors.Wrap(err, "deleteall Games")
	}
	return res.RowsAffected()
}
