// Code generated by gnorm, DO NOT EDIT!

package twitchuser

import (
	"context"
	"time"

	"github.com/coadler/twitch/internal/models"
	"github.com/pkg/errors"
)

// TableName is the primary table that this particular gnormed file deals with.
const TableName = "twitch_user"

// Row represents a row from 'twitch_user'.
type Row struct {
	ID              string    // id (PK)
	BroadcasterType string    // broadcaster_type
	CreatedAt       time.Time // created_at
	Description     string    // description
	DisplayName     string    // display_name
	Login           string    // login
	OfflineImageURL string    // offline_image_url
	ProfileImageURL string    // profile_image_url
	Type            string    // type
	UpdatedAt       time.Time // updated_at
	ViewCount       int       // view_count
}

// Field values for every column in TwitchUser.
var (
	BroadcasterTypeCol models.StringField   = "broadcaster_type"
	CreatedAtCol       models.TimeTimeField = "created_at"
	DescriptionCol     models.StringField   = "description"
	DisplayNameCol     models.StringField   = "display_name"
	IDCol              models.StringField   = "id"
	LoginCol           models.StringField   = "login"
	OfflineImageURLCol models.StringField   = "offline_image_url"
	ProfileImageURLCol models.StringField   = "profile_image_url"
	TypeCol            models.StringField   = "type"
	UpdatedAtCol       models.TimeTimeField = "updated_at"
	ViewCountCol       models.IntField      = "view_count"
)

// All retrieves all rows from 'twitch_user' as a slice of Row.
func All(ctx context.Context, db models.DB) ([]*Row, error) {
	const sqlstr = `SELECT
		broadcaster_type, created_at, description, display_name, id, login, offline_image_url, profile_image_url, type, updated_at, view_count
		FROM public.twitch_user`

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, errors.Wrap(err, "query TwitchUser")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.BroadcasterType,
			&r.CreatedAt,
			&r.Description,
			&r.DisplayName,
			&r.ID,
			&r.Login,
			&r.OfflineImageURL,
			&r.ProfileImageURL,
			&r.Type,
			&r.UpdatedAt,
			&r.ViewCount,
		)
		if err != nil {
			return nil, errors.Wrap(err, "all TwitchUser")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// CountQuery retrieve one row from 'twitch_user'.
func CountQuery(ctx context.Context, db models.DB, where models.WhereClause) (int, error) {
	const origsqlstr = `SELECT
		count(*) as count
		FROM public.twitch_user WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	count := 0
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "count TwitchUser")
	}
	return count, nil
}

// Query retrieves rows from 'twitch_user' as a slice of Row.
func Query(ctx context.Context, db models.DB, where models.WhereClause) ([]*Row, error) {
	const origsqlstr = `SELECT
		id, login, display_name, type, broadcaster_type, description, profile_image_url, offline_image_url, view_count, created_at, updated_at
		FROM public.twitch_user WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.Wrap(err, "query TwitchUser")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID,
			&r.Login,
			&r.DisplayName,
			&r.Type,
			&r.BroadcasterType,
			&r.Description,
			&r.ProfileImageURL,
			&r.OfflineImageURL,
			&r.ViewCount,
			&r.CreatedAt,
			&r.UpdatedAt,
		)
		if err != nil {
			return nil, errors.Wrap(err, "query TwitchUser")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// QueryOrder retrieves rows from 'twitch_user' as a slice of Row in a particular order.
func QueryOrder(ctx context.Context, db models.DB, where models.WhereClause, orderby models.OrderBy) ([]*Row, error) {
	const origsqlstr = `SELECT
		id, login, display_name, type, broadcaster_type, description, profile_image_url, offline_image_url, view_count, created_at, updated_at
		FROM public.twitch_user WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + orderby.String()

	var vals []*Row
	q, err := db.QueryContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return nil, errors.Wrap(err, "query TwitchUser")
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID,
			&r.Login,
			&r.DisplayName,
			&r.Type,
			&r.BroadcasterType,
			&r.Description,
			&r.ProfileImageURL,
			&r.OfflineImageURL,
			&r.ViewCount,
			&r.CreatedAt,
			&r.UpdatedAt,
		)
		if err != nil {
			return nil, errors.Wrap(err, "query TwitchUser")
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// One retrieve one row from 'twitch_user'.
func One(ctx context.Context, db models.DB, where models.WhereClause) (*Row, error) {
	const origsqlstr = `SELECT
		id, login, display_name, type, broadcaster_type, description, profile_image_url, offline_image_url, view_count, created_at, updated_at
		FROM public.twitch_user WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&r.ID,
		&r.Login,
		&r.DisplayName,
		&r.Type,
		&r.BroadcasterType,
		&r.Description,
		&r.ProfileImageURL,
		&r.OfflineImageURL,
		&r.ViewCount,
		&r.CreatedAt,
		&r.UpdatedAt,
	)
	if err != nil {
		return nil, errors.Wrap(err, "queryOne TwitchUser")
	}
	return r, nil
}

// First retrieve one row from 'twitch_user' when sorted by orderby.
func First(ctx context.Context, db models.DB, where models.WhereClause, orderby models.OrderBy) (*Row, error) {
	const origsqlstr = `SELECT
		id, login, display_name, type, broadcaster_type, description, profile_image_url, offline_image_url, view_count, created_at, updated_at
		FROM public.twitch_user WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") " + orderby.String()

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr, where.Values()...).Scan(&r.ID,
		&r.Login,
		&r.DisplayName,
		&r.Type,
		&r.BroadcasterType,
		&r.Description,
		&r.ProfileImageURL,
		&r.OfflineImageURL,
		&r.ViewCount,
		&r.CreatedAt,
		&r.UpdatedAt,
	)
	if err != nil {
		return nil, errors.Wrap(err, "queryFirst TwitchUser")
	}
	return r, nil
}

// Find retrieves a row from 'twitch_user' by its primary key(s).
func Find(ctx context.Context, db models.DB,
	id string,
) (*Row, error) {
	const sqlstr = `SELECT
		broadcaster_type, created_at, description, display_name, id, login, offline_image_url, profile_image_url, type, updated_at, view_count
	FROM public.twitch_user WHERE ( id = $1 )`

	r := &Row{}
	err := db.QueryRowContext(ctx, sqlstr,
		id,
	).Scan(&r.BroadcasterType,
		&r.CreatedAt,
		&r.Description,
		&r.DisplayName,
		&r.ID,
		&r.Login,
		&r.OfflineImageURL,
		&r.ProfileImageURL,
		&r.Type,
		&r.UpdatedAt,
		&r.ViewCount,
	)
	if err != nil {
		return nil, errors.Wrap(err, "find TwitchUser")
	}
	return r, nil
}

// Insert inserts the row into the database.
func Insert(ctx context.Context, db models.DB, r *Row) error {
	const sqlstr = `INSERT INTO public.twitch_user ` +
		`(
			broadcaster_type, description, display_name, id, login, offline_image_url, profile_image_url, type, view_count
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9
		) ` +
		`RETURNING
			created_at, updated_at, id
		`

	err := db.QueryRowContext(ctx, sqlstr, &r.BroadcasterType,

		&r.Description,

		&r.DisplayName,

		&r.ID,

		&r.Login,

		&r.OfflineImageURL,

		&r.ProfileImageURL,

		&r.Type,

		&r.ViewCount,
	).Scan(&r.CreatedAt, &r.UpdatedAt, &r.ID)

	return errors.Wrap(err, "insert TwitchUser")
}

// Update updates the Row in the database.
func Update(ctx context.Context, db models.DB, r *Row) error {
	const sqlstr = `UPDATE public.twitch_user SET (
			broadcaster_type, description, display_name, id, login, offline_image_url, profile_image_url, type, view_count
		) = (
			$1, $2, $3, $4, $5, $6, $7, $8, $9
		) WHERE
	        id = $10
		RETURNING
			created_at, updated_at
		`

	err := db.QueryRowContext(ctx, sqlstr, r.BroadcasterType, r.Description, r.DisplayName, r.ID, r.Login, r.OfflineImageURL, r.ProfileImageURL, r.Type, r.ViewCount, r.ID).Scan(&r.CreatedAt, &r.UpdatedAt)
	return errors.Wrap(err, "update TwitchUser:")
}

// InsertIgnore inserts the row into the database but ignores conflicts
func InsertIgnore(ctx context.Context, db models.DB, r *Row, constraint string) error {
	sqlstr := `INSERT INTO public.twitch_user ` +
		`(
			broadcaster_type, description, display_name, id, login, offline_image_url, profile_image_url, type, view_count
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9
		) ` +
		`ON CONFLICT ON CONSTRAINT ` + constraint + ` DO NOTHING `
	_, err := db.ExecContext(ctx, sqlstr, r.BroadcasterType, r.Description, r.DisplayName, r.ID, r.Login, r.OfflineImageURL, r.ProfileImageURL, r.Type, r.ViewCount)
	return errors.Wrap(err, "insert ignore TwitchUser")
}

// Set sets a single column on an existing row in the database.
func Set(ctx context.Context, db models.DB, set models.Where, where models.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.twitch_user SET ` +
		set.Field + " = $1 " +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{set.Value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "set TwitchUser")
	}
	return res.RowsAffected()
}

// AppendInt64 adds a value to a field
func AppendInt64(ctx context.Context, db models.DB, name string, value interface{}, where models.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.twitch_user SET ` +
		name + " = array_append(" + name + ", $1::bigint) " +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "append_int64 TwitchUser")
	}
	return res.RowsAffected()
}

// Inc increments the value of a single column on an existing row in the database.
func Inc(ctx context.Context, db models.DB, inc models.Where, where models.WhereClause) (int64, error) {
	idx := 2
	sqlstr := `UPDATE public.twitch_user SET ` +
		inc.Field + " = " + inc.Field + " + $1" +
		` WHERE ` +
		where.String(&idx)

	res, err := db.ExecContext(ctx, sqlstr, append([]interface{}{inc.Value}, where.Values()...)...)
	if err != nil {
		return 0, errors.Wrap(err, "inc TwitchUser")
	}
	return res.RowsAffected()
}

// Upsert performs an insert-or-update in one DB call for TwitchUser.
// Unlike insert, upsert requires that you have set any IDs on the row you're upserting.
// NOTE: PostgreSQL 9.5+ only
func Upsert(ctx context.Context, db models.DB, r *Row) error {

	const sqlstr = `INSERT INTO public.twitch_user (
		broadcaster_type, description, display_name, id, login, offline_image_url, profile_image_url, type, view_count
	) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8, $9
	) ON CONFLICT (id) DO UPDATE SET (
		broadcaster_type, description, display_name, id, login, offline_image_url, profile_image_url, type, view_count
	) = (
		$1, $2, $3, $4, $5, $6, $7, $8, $9
	)`

	_, err := db.ExecContext(ctx, sqlstr, r.BroadcasterType, r.Description, r.DisplayName, r.ID, r.Login, r.OfflineImageURL, r.ProfileImageURL, r.Type, r.ViewCount)
	return errors.Wrap(err, "upsert TwitchUser")
}

// Delete deletes the Row from the database. Returns the number of items deleted.
func Delete(ctx context.Context,
	db models.DB,
	id string,
) (int64, error) {
	const sqlstr = `DELETE FROM public.twitch_user 
	WHERE
	  id = $1
	`

	res, err := db.ExecContext(ctx, sqlstr, id)
	if err != nil {
		return 0, errors.Wrap(err, "delete TwitchUser")
	}
	rows, err := res.RowsAffected()
	if err != nil {
		return 0, err
	}
	return rows, nil
}

// DeleteWhere deletes Rows from the database and returns the number of rows deleted.
func DeleteWhere(ctx context.Context, db models.DB, where models.WhereClause) (int64, error) {
	const origsqlstr = `DELETE FROM public.twitch_user WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	res, err := db.ExecContext(ctx, sqlstr, where.Values()...)
	if err != nil {
		return 0, errors.Wrap(err, "delete TwitchUser")
	}
	return res.RowsAffected()
}

// DeleteAll deletes all Rows from the database and returns the number of rows deleted.
func DeleteAll(ctx context.Context, db models.DB) (int64, error) {
	const sqlstr = `DELETE FROM public.twitch_user`

	res, err := db.ExecContext(ctx, sqlstr)
	if err != nil {
		return 0, errors.Wrap(err, "deleteall TwitchUser")
	}
	return res.RowsAffected()
}
